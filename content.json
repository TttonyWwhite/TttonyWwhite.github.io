{"pages":[],"posts":[{"title":"Exceptions are Gotos","text":"Exceptions, they are one of those most complex and ridiculous thing ever devised ——Jonathan Blow Programming languages differ substantially in their notion of what is an exception. Your notion of Exception in Python, Java, are totally different from other language’s “exception”. Exceptions, in most imperative languages (e.g. Java, Python, JavaScript), is a form of goto. In some languages, “exception” is just a syntactic form of goto, and THAT IS ALL. You write if statement to check condition, and if so and so, you call “throw”, which jumps to a “catch” in YOUR CODE. That’s ALL. (for example, emacs lisp. [see Emacs Lisp: Exit Loop/Function, catch/throw]) In some languages, such as Java, Python, exception is more than just goto, but, goto with a tree of gotos, which runs out of your control. You can simply “throw”, or simply “try”, and the language will do things in a magic realm. Google’s new language golang, does not have exceptions, because the designers consider Exceptions harmful. If you don’t like the typical notion of Exceptions in {C++, Java, Python}, be cheered that many well-known expert programers, do not like them neither, and never use such feature in their own code. Semipredicate问题Semipredicate发生在一个可能会出错的子程序试图返回一个有效值时，此时，调用函数无法确认接收到的值是有效值还是发生错误的信号。 解决这个问题的一种办法就是Exceptions，但是异常机制的引入在程序中造成了”invisible exit points that runs in some magic realm”, 降低了程序的可读性。 为了避免Exceptions造成的问题，可以使用以下几种解决办法： 返回列表，列表的第一个元素包含子程序返回值，第二个元素包含错误码，第三个元素包含供程序员检查的错误信息。 一些语言支持多返回值，比如Common Lisp. 使用“外部参数”，一个例子就是C或者C++中的指针，子程序运行时可以修改一个指针所指向的值，这样在子程序结束时，调用函数可以查看这个值来确认子程序是否发生错误。 返回一个对象。 使用全局变量，记录子程序退出时的状态。 返回特殊值，比如nil, null, -1等。 返回一个特殊的类型。 异常的分类 those languages in which exceptions “are designed to be used as flow control structures”; according to this paper, Ada, C++, Java, Modula-3, ML, OCaml, Python, and Ruby fall in this category those languages in which exceptions “are designed to represent and handle abnormal, unpredictable, erroneous situations”; according to the paper these include: C#, Common Lisp, Eiffel, and Modula-2 by Joseph R.kiniry 所以结论就是，如果是为了控制程序的逻辑(flow control)，那就尽量不要使用异常机制，而应该将异常用在错误处理上。 参考资料： http://xahlee.info/comp/why_i_hate_exceptions.html","link":"/2018/11/04/Exceptions-are-Gotos/"},{"title":"Language Implementation Patterns笔记","text":"Language Implementation Patterns 笔记 Chapter 2 Basic Parsing Patterns2.1 Identify Phrase Structureparse tree 2.2 Building Recursive-Descent Parsers The basic method: make a function for each named substructure of the parse tree. Each function execute code to match its children. LL(1) Building Recursive-Descent Parser First L means “read the input from left to right”. Second L means “descend into parse tree children from left to right”. 1 means how many chars we look ahead. 2.3 Parser Construction Using a Grammar DSLThe parsing functions above are similar and consistent, so we need to find a way to build this functions automaticlly. Grammars are concise and act like functional specifications for languages. Substructures in the parse tree and functions in the parser correspond to rules in a grammar. use syntax diagram to visualize the control flow 2.4 Tokenizer Sentences词法: Recognizers that feed off character streams are called tokenizers or leaxers. Example: lists of names such as [a,b,c] and nested lists such as [a, [b,c],c]. 词法分析和语法分析的设计模式是相似的。区别在于输入的符号，词法分析器接受的输入是characters，而语法分析器接受的输入是tokens。 Classic Parsing Patterns 1 Mapping Grammars to Recursive-Descent Recognizers Converting Rules 对语法中的每一个规则 r，建立一个同名方法 123public void r(){ ...} Converting Tokens Token references for token type T become calls to match(T). match( ) is a support method in Parser that consumes a token if T is the current lookahead token. If there is a mismatch, match( ) throws an exception 对于每一个token，需要定义种别码 1234public static final int T = &lt;&lt;sequential-integer&gt;&gt;;//对于错误和无效的tokenpublic static final int INVALID_TOKEN_TYPE = 0;public static final int EOF = -1; Converting Subrules 对于以下的subrules (&lt;&gt;|&lt;&gt;|..|&lt;) (T)? looks like 1if(&lt;&lt;lookahead-is-T&gt;&gt;) {match(T);} (…)+ become do-while loops 123do { &lt;&lt;code-matching-alternatives&gt;&gt;} while (&lt;&lt;lookahead-predicts-an-alt-of-subrule&gt;&gt;) (…)* looks like 123while (&lt;&lt;lookahead-predicts-an-alt-of-subrule&gt;&gt;) { &lt;&lt;code-matching-alternatives&gt;&gt;} 2. LL(1) Recursive-Descent Lexer3. LL(1) Recursive-Descent Parser​ Compute lookahead sets: First and Follow 4. LL(K) Recursive-Descent Parser​ The strength of a recursive-descent parser depends entirely on the strength of its lookahead decision. By allowing a lager (but still fixed) lookahead buffer, we get a parser strong enough for most computer language. Chapter3 Enhanced Parsing Patterns3.1 Parsing with Arbitrary LookaheadSometimes LL(k) method is too weak to distinguish function definitions from declarations using a natural grammar. For example: 在这种情况下，需要用到Backtracking Parser. Backtracking Parser 试探性地进行语法分析，如果不能匹配，就回溯输入，再进行下一次尝试。 试探性尝试存在顺序，这样规定好的顺序可以解决语法上的不确定性。 3.3 Directing the Parse with Semantic InformationSome programming languages have context-sensitive phrases. To handle context-sensitive phrases with context-free parser, we have to predicate alternatives. In effect, a predicate is just a run-time boolean test that says when it’s OK to match an alternative","link":"/2018/11/04/Language-Implementation-Patterns笔记/"}],"tags":[],"categories":[{"name":"技术","slug":"技术","link":"/categories/技术/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"}]}