{"pages":[],"posts":[{"title":"使用Arduino实现一个简单的统计长按次数的程序","text":"使用Arduino实现一个简单的统计长按次数的程序 代码比较简单，只有几个注意点要提一下。 我用的是Arduino Uno的板子，所以只有两个串口能收到中断请求。所以按钮要接在串口0或1上。 另外在attachInterrupt函数里，第一个参数是中断串口号，这里不能直接写串口的数字号，需要用digitalPinToInterrupt函数转换一下。在官方文档里这样是推荐的写法，而我一开始没这么写的时候就没法收到中断请求。 实现功能的思路是根据按下按钮和松开会触发两次中断产生的。设置一个状态量，记录这时是按下还是松开，如果是按下，就用mills()记录时间。如果是松开，就用现在的时间减去之间记录的时间，这样就得到了按住按钮的时间。然后再判断是不是长按。 作业要求是要用到FSM，也就是有限状态机。但是这个程序非常简单，所以就直接用if-else实现了。毕竟if-else也是有限状态机的一种实现方式嘛。 具体代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344const byte ledPin = 13;const byte interruptPin = 2;volatile byte state = LOW;int count = 0;boolean is_begin = true;int t1 = 0;int t2 = 0;void setup() { pinMode(ledPin, OUTPUT); pinMode(interruptPin, INPUT_PULLUP); Serial.begin(9600); attachInterrupt(digitalPinToInterrupt(interruptPin), pressed, RISING);}void loop() { //Serial.println(count); digitalWrite(ledPin, state);}void pressed() { if (is_begin) { Serial.println(\"pressed\"); t1 = millis(); is_begin = false; } else { Serial.println(\"released\"); t2 = millis() - t1; Serial.println(t2); if (t2 &gt;= 1000) { //是长按，计数 count++; Serial.print(\"long press times: \"); Serial.println(count); } is_begin = true; } delay(500); //消抖 }","link":"/2018/12/04/ArduinoFSM/"},{"title":"Vue.js页面后退时数据缓存问题","text":"Leetcode Median of two sorted array解题报告 Median of two sorted array是leetcode上的第四题，如果要满足时间复杂度要求的话，算是一道相当难的题了。 题目大致意思是，有两个排好序的数组，现在要找出这两个数组全部元素的中位数。 看完题目的第一想法是——归并排序，把两个数组排成一个数组再得到中位数。按照这个思路，代码可以很简单的实现。 1234567891011121314151617181920public double findMedianSortedArrays(int[] nums1, int[] nums2) { int[] total = new int[nums1.length + nums2.length]; // 合并后的数组 int i = 0, j = 0; // 用于遍历两个数组的index for (int k = 0;k &lt; nums1.length + nums2.length;k++) { if (i &gt;= nums1.length) total[k] = nums2[j++]; // 如果一个数组已经遍历完了，那么不用比较大小，直接把另一个数组的所有元素接到total数组中 else if (j &gt;= nums2.length) total[k] = nums1[i++]; else if (nums1[i] &lt; nums2[j]) total[k] = nums1[i++]; // 把小的元素加到total数组后，index+1 else total[k] = nums2[j++]; } double median = 0; if (total.length % 2 == 0) { median = (total[total.length / 2 -1] + total[total.length / 2]) / 2.0; } else median = total[total.length / 2]; return median; } 这样的做法非常直观和暴力，提交代码也是可以通过的。但是对复杂度进行分析就可以知道，由于归并排序是一种稳定的排序算法，所以无论如何都是会遍历完两个数组的所有元素的。其平均复杂度为O(nlogn)，显然是超出了题目要求的O(log (m+n))的。 研究了一段时间后，我发现关键问题在于：寻找中位数时，是可以逐渐将部分元素剔除的，通过降低问题的规模就可以降低复杂度。 接下来的这个方法中有很关键的一个转化是：求一个长度为k的数组的中位数也就是求这个数组中第k/2小的元素。对于两个数组来说，也是同样的道理。 假设两个数组的大小分别为m和n，那我们要求的就是所有元素中第 (m + n) / 2 大的元素。（由于数组序号是0开始，实际上应该再加1）。 另外，由于求中位数根据数组长度的奇偶性会分成两种情况，为了避免分情况讨论，可以用一个小trick，那就是求 (m + n + 1) / 2和 (m + n + 2) / 2两数的平均数(注意这里是加了1的情况，下文为了行文方便，就不加了)。因为int型变量向下取整的性质，当两个数组长度和为偶数时，这两个序号其实是相等的。 好了，准备工作做完了，我们开始正式分析这个问题。 假设有A，B两个数组，我们可以通过两个数组的中位数把两个数组分为四部分。 接下来我们比较两个中位数的大小，如果mid1 &lt; mid2，那么我们可以断定1号部分一定是全部小于4号部分的，也就是说这四个部分的排序一定是1234或是1243。那么我们就可以断定，最后要求的中位数一定不在1号部分中。所以我们可以在接下来的递归中把1号部分删除。 在把1号部分剔除之前，我们要找的是第(m+n) / 2号元素，那么剔除之后，我们要找的是多少号元素呢？ 我们可以做一个简单的分析，如果在一次递归中，要找的中位数是所有元素中第k小的，那么也就是说有2k个元素。这次递归中我们剔除了k/2个元素，可以确定的是，这k/2个元素一定都是在要找的中位数前面的。也就是说，要找的中位数的序号大小减小了k/2。 基于这样的思想，我们可以递归地对两个数组进行遍历。递归基分为三种情况： 如果A数组遍历完毕，就直接从B数组中找中位数 如果B数组遍历完毕也类似 如果每次减少k/2直到k == 1，也就是说我们要找的中位数是A，B数组剩下的元素中最小的，那么我们只要返回A，B数组中现在的第一个元素中最小的那个就行了。 这个算法更快的原因是，每次递归我们都抛弃了一部分元素，在接下来的递归中就不会去理会这些元素，从而减少了重复工作。具体代码如下： 123456789101112131415161718public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length, left = (m+n+1)/2, right = (m+n+2)/2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; //使用到小trick的地方 } private int findKth(int[] nums1, int i, int[] nums2, int j, int k) { if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); // 三种递归基情况 int midVal1 = (i + k / 2 - 1 &lt; nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE; // 如果求得的mid超出数组的长度，那么就不参与讨论 int midVal2 = (j + k / 2 - 1 &lt; nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE; // 需要注意的是，两个mid不可能同时超出数组的长度，所以这么写是安全的 if (midVal1 &lt; midVal2) return findKth(nums1, i + k / 2, nums2, j, k - k / 2); // i+k/2就是抛弃了部分元素的过程 else return findKth(nums1, i, nums2, j + k / 2, k - k / 2); }","link":"/2019/05/09/Leetcode 第4题 Median of two sorted array解题报告/"},{"title":"Language Implementation Patterns笔记","text":"Language Implementation Patterns 笔记 Chapter 2 Basic Parsing Patterns2.1 Identify Phrase Structureparse tree 2.2 Building Recursive-Descent Parsers The basic method: make a function for each named substructure of the parse tree. Each function execute code to match its children. LL(1) Building Recursive-Descent Parser First L means “read the input from left to right”. Second L means “descend into parse tree children from left to right”. 1 means how many chars we look ahead. 2.3 Parser Construction Using a Grammar DSLThe parsing functions above are similar and consistent, so we need to find a way to build this functions automaticlly. Grammars are concise and act like functional specifications for languages. Substructures in the parse tree and functions in the parser correspond to rules in a grammar. use syntax diagram to visualize the control flow 2.4 Tokenizer Sentences词法: Recognizers that feed off character streams are called tokenizers or leaxers. Example: lists of names such as [a,b,c] and nested lists such as [a, [b,c],c]. 词法分析和语法分析的设计模式是相似的。区别在于输入的符号，词法分析器接受的输入是characters，而语法分析器接受的输入是tokens。 Classic Parsing Patterns 1 Mapping Grammars to Recursive-Descent Recognizers Converting Rules 对语法中的每一个规则 r，建立一个同名方法 123public void r(){ ...} Converting Tokens Token references for token type T become calls to match(T). match( ) is a support method in Parser that consumes a token if T is the current lookahead token. If there is a mismatch, match( ) throws an exception 对于每一个token，需要定义种别码 1234public static final int T = &lt;&lt;sequential-integer&gt;&gt;;//对于错误和无效的tokenpublic static final int INVALID_TOKEN_TYPE = 0;public static final int EOF = -1; Converting Subrules 对于以下的subrules (&lt;&gt;|&lt;&gt;|..|&lt;) (T)? looks like 1if(&lt;&lt;lookahead-is-T&gt;&gt;) {match(T);} (…)+ become do-while loops 123do { &lt;&lt;code-matching-alternatives&gt;&gt;} while (&lt;&lt;lookahead-predicts-an-alt-of-subrule&gt;&gt;) (…)* looks like 123while (&lt;&lt;lookahead-predicts-an-alt-of-subrule&gt;&gt;) { &lt;&lt;code-matching-alternatives&gt;&gt;} 2. LL(1) Recursive-Descent Lexer3. LL(1) Recursive-Descent Parser​ Compute lookahead sets: First and Follow 4. LL(K) Recursive-Descent Parser​ The strength of a recursive-descent parser depends entirely on the strength of its lookahead decision. By allowing a lager (but still fixed) lookahead buffer, we get a parser strong enough for most computer language. Chapter3 Enhanced Parsing Patterns3.1 Parsing with Arbitrary LookaheadSometimes LL(k) method is too weak to distinguish function definitions from declarations using a natural grammar. For example: 在这种情况下，需要用到Backtracking Parser. Backtracking Parser 试探性地进行语法分析，如果不能匹配，就回溯输入，再进行下一次尝试。 试探性尝试存在顺序，这样规定好的顺序可以解决语法上的不确定性。 3.3 Directing the Parse with Semantic InformationSome programming languages have context-sensitive phrases. To handle context-sensitive phrases with context-free parser, we have to predicate alternatives. In effect, a predicate is just a run-time boolean test that says when it’s OK to match an alternative","link":"/2018/11/04/Language-Implementation-Patterns笔记/"},{"title":"Exceptions are Gotos","text":"Exceptions, they are one of those most complex and ridiculous thing ever devised ——Jonathan Blow Programming languages differ substantially in their notion of what is an exception. Your notion of Exception in Python, Java, are totally different from other language’s “exception”. Exceptions, in most imperative languages (e.g. Java, Python, JavaScript), is a form of goto. In some languages, “exception” is just a syntactic form of goto, and THAT IS ALL. You write if statement to check condition, and if so and so, you call “throw”, which jumps to a “catch” in YOUR CODE. That’s ALL. (for example, emacs lisp. [see Emacs Lisp: Exit Loop/Function, catch/throw]) In some languages, such as Java, Python, exception is more than just goto, but, goto with a tree of gotos, which runs out of your control. You can simply “throw”, or simply “try”, and the language will do things in a magic realm. Google’s new language golang, does not have exceptions, because the designers consider Exceptions harmful. If you don’t like the typical notion of Exceptions in {C++, Java, Python}, be cheered that many well-known expert programers, do not like them neither, and never use such feature in their own code. Semipredicate问题Semipredicate发生在一个可能会出错的子程序试图返回一个有效值时，此时，调用函数无法确认接收到的值是有效值还是发生错误的信号。 解决这个问题的一种办法就是Exceptions，但是异常机制的引入在程序中造成了”invisible exit points that runs in some magic realm”, 降低了程序的可读性。 为了避免Exceptions造成的问题，可以使用以下几种解决办法： 返回列表，列表的第一个元素包含子程序返回值，第二个元素包含错误码，第三个元素包含供程序员检查的错误信息。 一些语言支持多返回值，比如Common Lisp. 使用“外部参数”，一个例子就是C或者C++中的指针，子程序运行时可以修改一个指针所指向的值，这样在子程序结束时，调用函数可以查看这个值来确认子程序是否发生错误。 返回一个对象。 使用全局变量，记录子程序退出时的状态。 返回特殊值，比如nil, null, -1等。 返回一个特殊的类型。 异常的分类 those languages in which exceptions “are designed to be used as flow control structures”; according to this paper, Ada, C++, Java, Modula-3, ML, OCaml, Python, and Ruby fall in this category those languages in which exceptions “are designed to represent and handle abnormal, unpredictable, erroneous situations”; according to the paper these include: C#, Common Lisp, Eiffel, and Modula-2 by Joseph R.kiniry 所以结论就是，如果是为了控制程序的逻辑(flow control)，那就尽量不要使用异常机制，而应该将异常用在错误处理上。 参考资料： http://xahlee.info/comp/why_i_hate_exceptions.html","link":"/2018/11/04/Exceptions-are-Gotos/"},{"title":"Vue.js页面后退时数据缓存问题","text":"Vue.js页面后退时数据缓存问题 在大作业开发过程中遇见了一个bug， 大致情况如下： PersonalCenter页面中有一个订单列表，点击列表中的订单可以前进到订单详情界面。在详情界面中，有一个表格显示订单内容，第一次进入详情界面的时候是可以正常显示的，但是如果浏览器后退，再点击另一个订单，那么这个订单详情页面中的表格就会包含上一个订单中的内容。初步猜测这是缓存策略的原因，于是在PersonalCenter页面在created中写了方法让A页面每次create的时候就会刷新一次，这个时候就能正常工作了。 首先要明确的一点是，这个页面组件是被keep-alive包裹的，所以Vue会缓存不活动的组件实例，而不是销毁它们。最上层代码如下： 在旁边的navbar中点击导航按钮就可以使router-view加载PersonalCenter页面。 查看Vue的文档可以知道，对于keep-alive包裹的组件，不能简单地采用created，mounted等生命周期钩子。这种情况下，页面第一次进入，钩子的触发顺序为created-&gt; mounted -&gt; activated，退出时触发deactivated，当再次进入（前进或后退）时，只触发activated。这也是出现bug的原因。 所以在浏览器中点击后退时，页面中的数据并不会被销毁，而是会保存下来。 进一步debug发现，进入第二个订单页面时，并不是所有的数据内容都是重复的。而是只有订单编号和订单内餐品的数据。检查代码发现，这两个数据的初始化和其他数据的确不相同。 首先，订单编号是获取url中的数据来的 一开始只在data中给orderId进行了赋值，所以当第二次进入订单详情页面时，由于页面中的数据没有被销毁，并且也没有对orderId重新进行赋值，还是使用了上一个订单的id。 而订单内餐品出现的错误则是一开始最令人困惑的，第二次进入订单详情页面居然会显示两个订单加在一起的餐品。原因在于下面这段代码： 其中products是用axios从后端获得到的数据，content是当前页面用来存放餐品的数组。由于content没有被重新赋值，所以再次进入这个页面时，content里还保存着上一个订单的数据，继续向content添加内容就造成了那个奇怪的bug。 至于其他数据为什么没有出错，这是因为其他数据在activated函数中都进行了重新赋值。 分析到这里，这个bug也很好解决了，只需要添加这两段代码： 在加载页面时，对orderId重新进行赋值。退出页面时，将content清空，这个神秘的bug就解决了。","link":"/2019/03/01/Vue.js页面后退时数据缓存问题/"},{"title":"Vue.js实现子组件修改父组件数据","text":"Vue.js实现子组件修改父组件元素 在Vue.js中，父组件传值到子组件是很简单的，只需要通过props。比如： 1234567&lt;!--父组件中--&gt;&lt;Child :data=&quot;dataForChild&quot;&gt;&lt;/Child&gt;&lt;!--子组件中--&gt;&lt;p&gt;{{ dataForChild }}&lt;/p&gt;export default { props: [&apos;dataForChild&apos;]} 子组件可以像使用自己data中数据一样使用props中的数据。但是要修改的话就会遇到问题了。查看文档可以知道，所有的prop都使得其父子prop之间形成了一个单向下行绑定，父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 但是如果确实需要修改props中的值，就需要换一种方法来做。我的理解就是子组件通知父组件，让父组件来修改这个值，这样就不违反单向下行绑定了。 还是用上面的例子，具体的做法是下面这样： 12345678910111213141516171819&lt;!--父组件中--&gt;&lt;Child :data=&quot;dataForChild&quot; dataChanged=&quot;onDataChange&quot;&gt;&lt;/Child&gt;methods: { onDataChange(val) { //这里的val就是子组件传过来的新值 //修改dataForChild中的值 }}&lt;!--子组件中--&gt;&lt;p&gt;{{ dataForChild }}&lt;/p&gt;export default { props: [&apos;dataForChild&apos;], methods: { function() { this.$emit(&apos;dataChanged&apos;, val) //通过这个方法来通知父组件修改prop中的值 } }} 通过以上的方法，就可以灵活地做到让子组件修改父组件传过来的数据。","link":"/2019/02/28/Vue中实现子组件修改父组件数据/"},{"title":"谈谈《深入理解Java虚拟机》中关于RuntimeConstantPoolOOM的问题","text":"RuntimeConstantPool 最近在读周志明先生的《深入理解Java虚拟机》一书，书中第二章关于方法区和运行时常量池溢出的部分有一段代码让我很困惑。代码如下： 但我自己在IDE中运行这段代码时却得不到相同的结果，甚至电脑会直接卡住。书中代码后面的解释说是jdk版本和intern函数的问题，但又语焉不详。仔细研究和查阅资料后发现，intern()函数在jdk7以及之后的版本中，并不会把调用这个函数的实例复制到常量池中，而只是在常量池中记录首次出现的实例的引用。所以对象实际上还是存储在Java堆上，存储在常量池中的只是引用而已。想要用引用来把常量池占满是非常困难的事，所以第一段代码就几乎进入了一个死循环。为了印证这个结论，我把jvm参数改成了 -Xms2m -Xmx2m -XX:+HeapDumpOnOutOfMemoryError。这样，如果Java堆发生了溢出，就会看到报错信息，结果也确实如此。 另外一个问题是周志明先生为了解释上面这个问题而写的一段测试代码。 尽管书中做了一些解释。但是为什么明明都是字符串，第二个条件判断表达式就会得到false呢？那是因为在jvm运行的过程中，除了我们自己写的类和方法，肯定还是有很多其他类，方法被实例化和运行的。这些类和方法也会向常量池中添加常量。这时候”java”就不是intern首次遇到的字符串实例了。返回的引用当然就不等于str2。 至于具体是哪个类或者哪个方法，jvm圈有名的R大，也是我的校友和学长在知乎上做过解释。 如何理解《深入理解java虚拟机》第二版中对String.intern()方法的讲解中所举的例子？ - RednaxelaFX的回答 - 知乎https://www.zhihu.com/question/51102308/answer/124441115","link":"/2019/03/11/谈谈《深入理解Java虚拟机》中关于RuntimeConstantPoolOOM的问题/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/技术/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"}]}